# About XXXX
This is a system implementing an advanced dialogue system that is capable of complex dialogue flow including choice trees and conditional branching. XXXX was first developed for the "Kandria"(link https://kandria.com) game, and has since been separated and made public in the hopes that it may find use elsewhere or inspire other developers to build similar systems.

XXXX is based on the "Markless"(link https://shirakumo.github.io/markless) document standard for its syntax and makes use of Markless' ability to be extended to add additional constructs useful for dialogue systems.

XXXX can compile dialogue from its base textual form into an efficient instruction set, which is then executed when the game is run. Execution of the dialogue is completely engine-agnostic, and only requires some "simple integration"(#writing a client) with a client protocol to run.

Thanks to Markless' extensibility, XXXX can also be further extended to include additional syntax and constructs that may be useful for your particular game.

## User Manual
This section covers the syntax and behaviour of XXXX dialogue. With any luck, after reading this you'll be able to write your own dialogue in XXXX. 

### Speech
Let's jump in with the classic:

:: markless
| Hello world!
::

This piece should just show the text ``Hello world!``. However, there's a bit of a problem: we don't know who's saying this! In order to annotate which character is speaking, we can add a source line:

:: markless
~ Hans
| Hello world!
::

Now we know that this is a character called ``Hans`` speaking the line. What the character's name should actually be depends on how your game engine organises things. For now we're assuming that we can just use the character's own name.

Often you'll also want to inform the system about how the character is feeling to accentuate the text and give it some more gravitas.

:: markless
~ Hans
| (:excited)Hello world!
::

Depending on your game this emote might correspond to the character changing their expression on screen as the text scrolls. For further flavour we can also use Markless' markup to change the text style.

:: markless
~ Hans
| (:excited)//Hello// **world**!
::

In Markless itself this would mean italic and bold, respectively, though the actual interpretation of it is up to the current game engine, and might have different effects like text shaking, wobbling, and so forth. Important to know here is only that there are several ways to markup text out of the box:

- ``**bold**``
- ``//italic//``
- ``__underline__``
- ``<-strikethrough->``
- And more, see the "Markless documentation"(https://shirakumo.github.io/markless).

Markup can also be nested, ``//like **so**!//``.

Finally, you can accentuate text by inserting pauses with en (``--``) and em (``---``) dashes. This can be quite useful to control the pacing of the text scroll to be more natural.

:: markless
~ Hans
| Helloooo-- world!
::

After a line of text, XXXX will insert a prompt for the player to continue so that there's no risk of the text scrolling by too fast for the player to read it.

:: markless
~ Hans
| Hey
| (:concerned)Are you still with me?
| (:frantic)Hang in there, Chris!
::

That should cover things for speech. Let's move on to more advanced stuff.

### Player Choice
XXXX allows you to make branching dialogue by presenting the player with a set of options. These options can even be gated behind checks. A basic choice is presented through a simple unordered list.

:: markless
~ Hans
| Are you getting this?
- Yes
- No
::

This will show the options ``Yes`` and ``No`` to the user, though no matter what they end up picking, neither of them actually do anything. Let's change that.

:: markless
~ Hans
| Are you getting this?
- Yes
  | Nice, well done!
- No
  | Sorry to hear that. What are you having trouble with?
::

The consequences of a choice follow after the choice's text, within the same list item. You can insert as many things as you want into the same list item as long as the item actually continues (no empty lines).

:: markless
~ Hans
| Are you getting this?
- Yes
  ~ Hannah
  | See, I told you, they'd get it no problem!
- No
  ~ Hannah
  | Ah what, really? Come on!
::

You can insert as many choices as you want, though obviously for game design reasons it's probably not wise to present too many at once.

Choices can also be nested to create dialogue trees.

! label tree
:: markless
~ Hans
| Are you getting this?
- Yes
  | Alright, are you ready for the next lesson?
  - Let's go
    | Wow, you're really blazing through this!
  - No, not quite yet
    | Ok, let's continue another time then
- No
  | What's bothering you?
  - I just need more time
    | Ok, no problem, let's try again another time then
  - I'm hopelessly confused
    | Give yourself some time then, come back to it later!
  - I hate this
    | Sorry to hear that. You don't have to continue if you don't want to!
::

As you might imagine, this can quickly get hard to see through, though. One way to make it a bit easier to read is to destructure the choices with labels and jumps.

### Labels and Jumps
In order to control flow and to help you section your dialogue, XXXX includes constructs to give points within the dialogue a name and to jump to such a name from another point in the dialogue. Creating a label is simple enough:

:: markless
> start
| How are ya?
::

This associates the label ``start`` with the speech ``How are ya?``, meaning once you jump to ``start`` it will start showing the text. Jumping to a label is also simple enough. For fun, let's recreate the classic "BASIC loop"(https://betanews.com/2014/05/01/10-print-hello-50-years-of-basic-20-goto-10/).

:: markless
> 10
| HELLO WORLD!
< 10
::

This will infinitely repeat, creating a truly never ending experience. All jokes aside, jumps and labels can come in handy when writing branching dialogue, since it allows us to create "empty choices" and to flatten the tree.

:: markless
> start
| Are you sure you want to give me a million dollars?
- Yes!
  | Wow, thanks so much, you're so generous!
- No
  | I implore you to reconsider.
  < start
::

This will cause the dialogue to keep looping back to the question if the player chooses the ``No`` option, effectively creating an empty choice as found in some games.

Similarly we can flatten choice trees by sectioning consequences out to labels. Transforming the "above choice"(#tree) we get this:

:: markless
~ Hans
| Are you getting this?
- Yes
  < Yes
- No
  < No

> Yes
| Alright, are you ready for the next lesson?
- Let's go
  | Wow, you're really blazing through this!
- No, not quite yet
  | Ok, let's continue another time then

> No
| What's bothering you?
- I just need more time
  | Ok, no problem, let's try again another time then
- I'm hopelessly confused
  | Give yourself some time then, come back to it later!
- I hate this
  | Sorry to hear that. You don't have to continue if you don't want to!
::

There's one small problem with this though, namely that once the ``Yes`` tree completes, it will continue execution and also do the ``No`` tree. This is pretty much never what we want, so instead we should be using sections to do this, which is another way of labelling:

:: markless
~ Hans
| Are you getting this?
- Yes
  < Yes
- No
  < No

# Yes
| Alright, are you ready for the next lesson?
- Let's go
  | Wow, you're really blazing through this!
- No, not quite yet
  | Ok, let's continue another time then

# No
| What's bothering you?
- I just need more time
  | Ok, no problem, let's try again another time then
- I'm hopelessly confused
  | Give yourself some time then, come back to it later!
- I hate this
  | Sorry to hear that. You don't have to continue if you don't want to!
::

Sections force an end of dialogue, so that if execution should hit upon a section header without it just jumping there, it'll automatically end. If we now want to go back to the main execution flow after either choice completes however, we can use a normal label again:

:: markless
~ Hans
| Are you getting this?
- Yes
  < Yes
- No
  < No
> Main
| Bye!

# Yes
| Alright, are you ready for the next lesson?
- Let's go
  | Wow, you're really blazing through this!
- No, not quite yet
  | Ok, let's continue another time then
< Main

# No
| What's bothering you?
- I just need more time
  | Ok, no problem, let's try again another time then
- I'm hopelessly confused
  | Give yourself some time then, come back to it later!
- I hate this
  | Sorry to hear that. You don't have to continue if you don't want to!
< Main
::

Note that all labels -- regardless of the syntax used to define them -- are global to a piece of dialogue though, so you can't use the same name twice.

Lets move on to another advanced topic, conditions and branching.

### Conditions
Sometimes dialogue needs to react to game state. Choices might need to be hidden, or a character might need to react in a different way depending on what the player has done so far. XXXX offers a couple of ways to do this. The most basic way is the conditional block.

:: markless
? have-water
| ~ Fireman
| | Quick, use the water to put out the fire!
::

In this dialogue, the Fireman will shout ``Quick, use the water to put out the fire!`` if ``have-water`` is true.

``have-water`` here is a placeholder for some kind of Lisp expression. This expression can be arbitrary Lisp code, and it is up to the game engine to control how that code is evaluated. Often the engine will add a variety of support functions and variables to help manage and check various parts of the game's state. We won't go into on Lisp syntax and semantics here, you'll want to consult another tutorial for that as it is a very complex topic.

The above conditional block can also include additional branches, and simply executes the first branch for which the test passes:

:: markless
? have-water
| ~ Fireman
| | Quick, use the water to put out the fire!
|? have-hose
| ~ Fireman
| | Blast it!
|?
| ~ Fireman
| | Someone get us some water, stat!
::

A branch with no condition always passes. The conditional block is thus similar to ``if/else if/else`` chains, or ``cond`` in Lisp.

Often however the full conditional block is too lengthy and bulky. For quick conditional dialogue pieces, the inline branch can also be used:

:: markless
~ Fireman
| [have-water Quick, use the water! | Get some water stat!]
::

Both forms of branching can be used to restrict choices behind a check as well.

:: markless
- [have-water Here, let me help!|]
  ~ Fireman
  | Then don't just stand there!
- I'll go get some water!
  ~ Fireman
  | And make it quick!
::

In this case if the ``have-water`` check fails, the option would not be available to the player.

One thing to watch out for when using conditional blocks to restrict choices is that since the block and speech both use the same syntax, you have to make sure to interrupt the conditional block before you can continue with speech. You can do this with another block like a source, or by using a clear (not empty!) line:

:: markless
- ? have-water
  | Here, let me help!
  
  | Then don't just stand there!
::

Note the two spaces on the seemingly empty line to continue the list item.

Both forms of conditionals can be nested arbitrarily, too, though you cannot nest a conditional block inside an inline conditional.

### Evaluation
Finally, often it's desired to cause changes to game state, or include dialogue particular to game state. Since integrating with game state is typically extremely specific to the game and engine being made at the time, XXXX just includes basic constructs to splice a Lisp value into text, and to evaluate arbitrary Lisp code.

While not ideal from a user perspective as it forces you to learn some Lisp, typically engine coders can provide enough shorthand functions for the dialogue system such that dialogue authors don't have to learn a lot of Lisp to get going.

The placeholder ``{form}`` evaluates the form and writes whatever the form returns as its value to text. This can be handy when you need to involve dynamic stuff like nicknames in a classic RPG:

:: markless
| Hi, my name is {(name character)}!
::

Dialogue also often needs to trigger changes in game state, be that in response to completing a dialogue or in response to a choice the user made. For this the ``eval`` instruction can be used.

:: markless
! eval (spawn 'dog)
::

Again, which functions and variables are available depends on the game and engine being built. Please consult your internal documentation on that.

### Misc
Markless includes a few additional constructs that can be helpful with XXXX, too. For instance, comments can be used to write notes for yourself about what a piece of dialogue is meant to do or in which context it occurs.

:: markless
; This is a note to myself and won't have any effect!
::

You can also emit warnings or even errors if there's a problem in the dialogue and you would like to make sure the game can't proceed yet.

:: markless
! error This isn't ready yet!
::

Again, consult the "Markless documentation"(http://shirakumo.github.io/markless/) for a complete outline of the Markless syntax and semantics.

This should cover everything that's supported by XXXX out of the box. Your engine may add extra constructs and support syntax. To see how to do that, please "read on"(#extension).

## Writing a Client


## Extension
